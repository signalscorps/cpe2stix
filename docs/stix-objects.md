# Modelling CPEs as STIX Objects

The STIX 2.1 Specification contains a Software SCO that can be used to construct these patterns, [here is the specification for it](https://docs.oasis-open.org/cti/stix/v2.1/csprd01/stix-v2.1-csprd01.html#_Toc16070740).

The problem here is CPEs cover applications (software), operating systems (also software), and hardware (not software).

As a trade-off to ensure consistency we decided to model all CPEs as Software SCOs regardless of whether they are software or not.

### New CPE Objects

cpe2stix constructs Software SCOs for CPEs as follows;

```json
{
    "type": "software",
    "spec_version": "2.1",
    "id": "software--<GENERATED BY STIX2 LIBRARY>",
    "name": "<cpes.titles.title>",
    "cpe": "<cpes.titles.cpe23Uri>",  
    "version": "<cpes.titles.cpe23Uri[version_section]>",
    "vendor": "<cpes.titles.cpe23Uri[vendor_section]>",
    "languages": [
        "<cpes.titles.lang>"
    ],
    "revoked": "<cpes.deprecated>",
    "extensions": {
        "extension-definition--6c453e0f-9895-498f-a273-2e2dda473377": {
            "extension_type": "property-extension",
            "nvd_cpe" : {
                "PRINTED JSON CPE FIELDS"
            }
        }
    }
}
```

As an example using `cpe:2.3:a:rusqlite_project:rusqlite:0.26.0:*:*:*:*:rust:*:*`;

```json
{
      "type": "software",
      "spec_version": "2.1",
      "id": "software--bbac7ad2-a550-4d4e-af5c-78feaf455f77",
      "name": "Rusqlite Project Rusqlite 0.26.0 for Rust",
      "cpe": "cpe:2.3:a:rusqlite_project:rusqlite:0.26.0:*:*:*:*:rust:*:*",  
      "version": "0.26.0",
      "vendor": "rusqlite_project",
      "languages": "*",
      "revoked": false,
      "extensions": {
        "extension-definition--6c453e0f-9895-498f-a273-2e2dda473377": {
            "extension_type": "property-extension",
            "nvd_cpe" : {
                "deprecated": false,
                "cpe23Uri": "cpe:2.3:a:rusqlite_project:rusqlite:0.26.0:*:*:*:*:rust:*:*",
                "lastModifiedDate": "2022-01-03T14:59Z",
                "titles": [
                    {
                        "title": "Rusqlite Project Rusqlite 0.26.0 for Rust",
                        "lang": "en_US"
                    }
                ],
                "refs": [
                    {
                        "ref": "https://github.com/rusqlite/rusqlite/releases",
                        "type": "Version"
                    },
                    {
                        "ref": "https://github.com/rusqlite/rusqlite",
                        "type": "Project"
                    },
                    {
                        "ref": "https://crates.io/crates/rusqlite",
                        "type": "Project"
                    }
                ],
                "deprecatedBy": [],
                "vulnerabilities": [
                    "CVE-2021-45713",
                    "CVE-2021-45714",
                    "CVE-2021-45715",
                    "CVE-2021-45716",
                    "CVE-2021-45717",
                    "CVE-2021-45718",
                    "CVE-2021-45719"
                ]
            }
        }
    }
}
```

### Dealing with CPE updates

As noted CPEs can be periodically updated (generally this is to deprecate them).

If a CPE already exists but is returned by the NVD as updated (because `lastModifiedDate` > last run time) then cpe2stix updates the original object, but does not change the `id` property in most cases.

It is important to note in the [STIX specification for the Software Object](https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_7rkyhtkdthok) that the ID contributing properties for it are `name`, `cpe`, `swid` (not used by cpe2stix), `vendor`, `version`. As such, if any of these fields are changed during an update (mappings shown below), a new object with a new `id` will be created for the changes.

* `name` = `<cpes.titles.title>`
* `cpe` = `<cpes.titles.cpe23Uri>`
* `vendor` = `<cpes.titles.cpe23Uri[vendor_section]>`
* `version` = `<cpes.titles.cpe23Uri[version_section]>`

We don't clean up the old object in the current implementation simply because updates to these fields are rare. Usually if any of these fields are modified the object is deprecated, and a new entry created by NVD. Typically updates happen to the `refs`, `deprecated`, `deprecatedBy`, and `vulnerabilities` properties.